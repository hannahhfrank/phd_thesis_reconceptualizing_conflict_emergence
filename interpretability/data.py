import pandas as pdimport numpy as npfrom functions import lag_groupped,simple_imp_grouped,linear_imp_groupedimport matplotlib.pyplot as plt# List of microstates:# http://ksgleditsch.com/data-4.htmlmicro_states={"Dominica":54,              "Grenada":55,              "Saint Lucia":56,              "Saint Vincent and the Grenadines":57,              "Antigua & Barbuda":58,              "Saint Kitts and Nevis":60,              "Monaco":221,              "Liechtenstein":223,              "San Marino":331,              "Andorra":232,              "Abkhazia":396,              "South Ossetia":397,              "São Tomé and Principe":403,              "Seychelles":591,              "Vanuatu":935,              "Kiribati":970,              "Nauru":971,              "Tonga":972,              "Tuvalu":973,              "Marshall Islands":983,              "Palau":986,              "Micronesia":987,              "Samoa":990}exclude={"German Democratic Republic":265,         "Czechoslovakia":315,         "Yugoslavia":345,         "Abkhazia":396,         "South Ossetia":397,         "Yemen, People's Republic of":680} exclude2 ={"Taiwan":713, # Not included in wdi           "Bahamas":31, # Not included in vdem           "Belize":80, # Not included in vdem           "Brunei Darussalam":835, # Not included in vdem           "Kosovo":347, # Mostly missing in wdi           "Democratic Peoples Republic of Korea":731} # Mostly missing in wdi############### UCDP ################ Loaducdp_sb=pd.read_csv("data/data_out/ucdp_cy_sb.csv",index_col=0)df = ucdp_sb[["year","gw_codes","country","best"]][~ucdp_sb['gw_codes'].isin(list(micro_states.values())+list(exclude.values())+list(exclude2.values()))]df.columns=["year","gw_codes","country","sb_fatalities"]# (1) Onset variable: Takes value one if fatalities are >= 1000/25, and preceding two# years remain below that threshold# Step 1: Get t-1 and t-2 lags of fatalitieydf=df.sort_values(by=['country', 'year'])df['lag1']=df.groupby('country')['sb_fatalities'].shift(1)df['lag2']=df.groupby('country')['sb_fatalities'].shift(2)# Step 2: Code onset variables df['onset']=np.where((df['sb_fatalities']>=25)&(df['lag1']<25)&(df['lag2']<25),1,0)df['onset2']=np.where((df['sb_fatalities']>=1000)&(df['lag1']<1000)&(df['lag2']<1000),1,0)df=df.drop('lag1',axis=1)df=df.drop('lag2',axis=1)# (2) Neighbor conflict history sb fatalities neighbors=pd.read_csv("data/data_out/cy_neighbors.csv",index_col=0)gw_codes=pd.read_csv("data/df_ccodes_gw.csv")# Country names in neighbors file and df_codes need to be the samegw_codes_s=gw_codes.loc[gw_codes["end"]>=1989]df_neighbors=pd.merge(left=df[["year","country","gw_codes","sb_fatalities"]],right=neighbors[["gw_codes","year","neighbors"]],on=["year","gw_codes"],how="left")df_neighbors["neighbors_fat"]=0# Loop through every observationfor i in range(len(df_neighbors)):        # If no neighbors pass on    if pd.isna(df_neighbors["neighbors"].iloc[i]):         pass    else:                # Get list of neighbors and set fatalities to zero        lst=df_neighbors["neighbors"].iloc[i].split(';')        counts=0                # For each neighbor        for x in lst:            # get gw code            c=int(gw_codes_s["gw_codes"].loc[gw_codes_s["country"]==x].iloc[0])                        # If neighbor exists in data (e.g., microstates are dropped), obtain fatalities and add to count            if df_neighbors["sb_fatalities"].loc[(df_neighbors["year"]==df_neighbors["year"].iloc[i])&(df_neighbors["gw_codes"]==c)].empty==False:                counts+=int(df_neighbors["sb_fatalities"].loc[(df_neighbors["year"]==df_neighbors["year"].iloc[i])&(df_neighbors["gw_codes"]==c)].iloc[0])                # If count is larger than zero, add to df        if counts>0:            df_neighbors.iloc[i, df_neighbors.columns.get_loc('neighbors_fat')] = counts# Lag ---> The total number of fatalities in the neighborhood in the previous yeardf_neighbors['d_neighbors_sb_fatalities_lag1'] = lag_groupped(df_neighbors,'country','neighbors_fat',1)df=pd.merge(left=df,right=df_neighbors[["year","gw_codes","d_neighbors_sb_fatalities_lag1"]],on=["year","gw_codes"],how="left")# Save version of data without imputation to check easily which values were imputeddf_noimp=df.copy() ########################## World Bank data ########################### Load wb data, previously retrived with the WB apieconomy=pd.read_csv("data/economy_wb.csv",index_col=0)# (1) GDP per capita # Imputationbase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PCAP.CD"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["NY.GDP.PCAP.CD"])base_imp_mean=simple_imp_grouped(base,"country",["NY.GDP.PCAP.CD"])base_imp_final["NY.GDP.PCAP.CD"] = base_imp_final["NY.GDP.PCAP.CD"].fillna(base_imp_mean["NY.GDP.PCAP.CD"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["NY.GDP.PCAP.CD"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["NY.GDP.PCAP.CD"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Rename variable and mergebase_imp_final = base_imp_final.rename(columns={"NY.GDP.PCAP.CD": 'gdp'})df=pd.merge(left=df,right=base_imp_final[["year","gw_codes","gdp"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=economy[["year","gw_codes","NY.GDP.PCAP.CD"]],on=["year","gw_codes"],how="left")df_noimp = df_noimp.rename(columns={"NY.GDP.PCAP.CD": 'gdp'})# (2) GDP growth (annual %) # Imputationbase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.MKTP.KD.ZG"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["NY.GDP.MKTP.KD.ZG"])base_imp_mean=simple_imp_grouped(base,"country",["NY.GDP.MKTP.KD.ZG"])base_imp_final["NY.GDP.MKTP.KD.ZG"] = base_imp_final["NY.GDP.MKTP.KD.ZG"].fillna(base_imp_mean["NY.GDP.MKTP.KD.ZG"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["NY.GDP.MKTP.KD.ZG"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["NY.GDP.MKTP.KD.ZG"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Rename variable and mergebase_imp_final = base_imp_final.rename(columns={"NY.GDP.MKTP.KD.ZG": 'growth'})df=pd.merge(left=df,right=base_imp_final[["year","gw_codes","growth"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=economy[["year","gw_codes","NY.GDP.MKTP.KD.ZG"]],on=["year","gw_codes"],how="left")df_noimp = df_noimp.rename(columns={"NY.GDP.MKTP.KD.ZG": 'growth'})# Remove countries which are completely missingdf=df.loc[df["country"]!="Djibouti"]df_noimp=df_noimp.loc[df_noimp["country"]!="Djibouti"]# (3) Population size# Imputationbase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","SP.POP.TOTL"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["SP.POP.TOTL"])base_imp_mean=simple_imp_grouped(base,"country",["SP.POP.TOTL"])base_imp_final["SP.POP.TOTL"] = base_imp_final["SP.POP.TOTL"].fillna(base_imp_mean["SP.POP.TOTL"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["SP.POP.TOTL"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["SP.POP.TOTL"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Rename variable and mergebase_imp_final = base_imp_final.rename(columns={"SP.POP.TOTL": 'pop'})df=pd.merge(left=df,right=base_imp_final[["year","gw_codes","pop"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=economy[["year","gw_codes","SP.POP.TOTL"]],on=["year","gw_codes"],how="left")df_noimp = df_noimp.rename(columns={"SP.POP.TOTL": 'pop'})# (4) Oil rents (% of GDP)# Imputationbase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","NY.GDP.PETR.RT.ZS"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["NY.GDP.PETR.RT.ZS"])base_imp_mean=simple_imp_grouped(base,"country",["NY.GDP.PETR.RT.ZS"])base_imp_final["NY.GDP.PETR.RT.ZS"] = base_imp_final["NY.GDP.PETR.RT.ZS"].fillna(base_imp_mean["NY.GDP.PETR.RT.ZS"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["NY.GDP.PETR.RT.ZS"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["NY.GDP.PETR.RT.ZS"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Rename variable and mergebase_imp_final = base_imp_final.rename(columns={"NY.GDP.PETR.RT.ZS": 'oil'})df=pd.merge(left=df,right=base_imp_final[["year","gw_codes","oil"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=economy[["year","gw_codes","NY.GDP.PETR.RT.ZS"]],on=["year","gw_codes"],how="left")df_noimp = df_noimp.rename(columns={"NY.GDP.PETR.RT.ZS": 'oil'})# (5) School enrollment, secondary, male (% gross)# Imputationbase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","SE.SEC.ENRR.MA"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["SE.SEC.ENRR.MA"])base_imp_mean=simple_imp_grouped(base,"country",["SE.SEC.ENRR.MA"])base_imp_final["SE.SEC.ENRR.MA"] = base_imp_final["SE.SEC.ENRR.MA"].fillna(base_imp_mean["SE.SEC.ENRR.MA"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["SE.SEC.ENRR.MA"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["SE.SEC.ENRR.MA"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Rename variable and mergebase_imp_final = base_imp_final.rename(columns={"SE.SEC.ENRR.MA": 'edu'})df=pd.merge(left=df,right=base_imp_final[["year","gw_codes","edu"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=economy[["year","gw_codes","SE.SEC.ENRR.MA"]],on=["year","gw_codes"],how="left")df_noimp = df_noimp.rename(columns={"SE.SEC.ENRR.MA": 'edu'})# Remove countries which are completely missingdf=df.loc[df["country"]!="Azerbaijan"]df=df.loc[df["country"]!="Haiti"]df=df.loc[df["country"]!="Moldova"]df=df.loc[df["country"]!="Turkmenistan"]df=df.loc[df["country"]!="Zambia"]df_noimp=df_noimp.loc[df_noimp["country"]!="Azerbaijan"]df_noimp=df_noimp.loc[df_noimp["country"]!="Haiti"]df_noimp=df_noimp.loc[df_noimp["country"]!="Moldova"]df_noimp=df_noimp.loc[df_noimp["country"]!="Turkmenistan"]df_noimp=df_noimp.loc[df_noimp["country"]!="Zambia"]# (6) Regulatory Quality: Estimate# Imputationbase=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=economy[["year","gw_codes","RQ.EST"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["RQ.EST"])base_imp_mean=simple_imp_grouped(base,"country",["RQ.EST"])base_imp_final["RQ.EST"] = base_imp_final["RQ.EST"].fillna(base_imp_mean["RQ.EST"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["RQ.EST"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["RQ.EST"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Rename variable and mergebase_imp_final = base_imp_final.rename(columns={"RQ.EST": 'regu'})df=pd.merge(left=df,right=base_imp_final[["year","gw_codes","regu"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=economy[["year","gw_codes","RQ.EST"]],on=["year","gw_codes"],how="left")df_noimp = df_noimp.rename(columns={"RQ.EST": 'regu'})# (7) Average Mean Surface Air Temperature # Imputationtemp=pd.read_csv("data/data_out/temp_cy.csv",index_col=0)base=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=temp[["gw_codes","year","temp"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["temp"])base_imp_mean=simple_imp_grouped(base,"country",["temp"])base_imp_final["temp"] = base_imp_final["temp"].fillna(base_imp_mean["temp"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["temp"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["temp"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","temp"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=temp[["year","gw_codes","temp"]],on=["year","gw_codes"],how="left")############## EPR ############### (8) Share powerless# Imputationerp=pd.read_csv("data/data_out/epr_cy.csv",index_col=0)base=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=erp[["year","gw_codes","powerless_share"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["powerless_share"])base_imp_mean=simple_imp_grouped(base,"country",["powerless_share"])base_imp_final["powerless_share"] = base_imp_final["powerless_share"].fillna(base_imp_mean["powerless_share"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["powerless_share"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["powerless_share"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Mergedf=pd.merge(left=df,right=base_imp_final[["year","gw_codes","powerless_share"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=erp[["year","gw_codes","powerless_share"]],on=["year","gw_codes"],how="left")################ V-Dem ################# (9) Liberal democracy index# Imputationvdem=pd.read_csv("data/data_out/vdem_cy.csv",index_col=0)base=df[["year","gw_codes","country"]].copy()base=pd.merge(left=base,right=vdem[["year","gw_codes","v2x_libdem"]],on=["year","gw_codes"],how="left")base_imp_final=linear_imp_grouped(base,"country",["v2x_libdem"])base_imp_mean=simple_imp_grouped(base,"country",["v2x_libdem"])base_imp_final["v2x_libdem"] = base_imp_final["v2x_libdem"].fillna(base_imp_mean["v2x_libdem"])# Validate#for c in base.country.unique():#    fig, axs = plt.subplots(1, 2, figsize=(10, 5))#    axs[0].plot(base["year"].loc[base["country"]==c], base["v2x_libdem"].loc[base["country"]==c])#    axs[1].plot(base_imp_final["year"].loc[base_imp_final["country"]==c], base_imp_final["v2x_libdem"].loc[base_imp_final["country"]==c])#    axs[0].set_title(c)#    plt.show()# Rename variable and mergebase_imp_final = base_imp_final.rename(columns={"v2x_libdem": 'libdem'})df=pd.merge(left=df,right=base_imp_final[["year","gw_codes","libdem"]],on=["year","gw_codes"],how="left")# Save version of data without imputationdf_noimp=pd.merge(left=df_noimp,right=vdem[["year","gw_codes","v2x_libdem"]],on=["year","gw_codes"],how="left")df_noimp = df_noimp.rename(columns={"v2x_libdem": 'libdem'})# Check datatypesdf.dtypesdf['d_neighbors_sb_fatalities_lag1']=df['d_neighbors_sb_fatalities_lag1'].astype('int64')# Save print(df.isnull().any())df.to_csv("data/df_interpret.csv")df_noimp.to_csv("data/df_interpret_noimp.csv")print(df.duplicated(subset=["year","gw_codes","country"]).any())print(df.duplicated(subset=["year","country"]).any())print(df.duplicated(subset=["year","gw_codes"]).any())